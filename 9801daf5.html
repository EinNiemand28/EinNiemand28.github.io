<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BUAA-OS-2024-Shell-Challenge | EinNiemand's Blog</title><meta name="author" content="EinNiemand"><meta name="copyright" content="EinNiemand"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Shell挑战性任务 任务要求 本次挑战性任务是在 lab6 实现的 MOS Shell 基础上继续实现新的功能。 实现功能 具体内容参考任务说明。（各测试点间无依赖关系） 关于shell 在 MOS 中，进程是一个很重要的概念，我们需要清楚 MOS 在运行的过程中存在哪些进程、这些进程之间的关系是什么，这有助于我们完成 shell 的相关任务。 比如，当我们启动 shell 时，它的 main">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA-OS-2024-Shell-Challenge">
<meta property="og:url" content="https://einniemand.top/9801daf5.html">
<meta property="og:site_name" content="EinNiemand&#39;s Blog">
<meta property="og:description" content="Shell挑战性任务 任务要求 本次挑战性任务是在 lab6 实现的 MOS Shell 基础上继续实现新的功能。 实现功能 具体内容参考任务说明。（各测试点间无依赖关系） 关于shell 在 MOS 中，进程是一个很重要的概念，我们需要清楚 MOS 在运行的过程中存在哪些进程、这些进程之间的关系是什么，这有助于我们完成 shell 的相关任务。 比如，当我们启动 shell 时，它的 main">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EinNiemand28/my-img@master/images/wallroom-3840x2400-bg-0f87d04.jpg">
<meta property="article:published_time" content="2024-06-28T10:10:02.000Z">
<meta property="article:modified_time" content="2024-08-20T10:36:43.447Z">
<meta property="article:author" content="EinNiemand">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/EinNiemand28/my-img@master/images/wallroom-3840x2400-bg-0f87d04.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://einniemand.top/9801daf5.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":0},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: EinNiemand","link":"链接: ","source":"来源: EinNiemand's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA-OS-2024-Shell-Challenge',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-20 10:36:43'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="EinNiemand's Blog" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" src="https://cdn.jsdelivr.net/gh/EinNiemand28/my-img@master/images/avatar.jpg"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
loadingPercentage.style.color = "black";
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if (currentValue === "100%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/EinNiemand28/my-img@master/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="EinNiemand's Blog"><span class="site-name">EinNiemand's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div><div id="nav-right"></div></nav><div id="post-info"><h1 class="post-title">BUAA-OS-2024-Shell-Challenge</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-28T10:10:02.000Z" title="发表于 2024-06-28 10:10:02">2024-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-20T10:36:43.447Z" title="更新于 2024-08-20 10:36:43">2024-08-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/BUAA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">BUAA操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAA-OS-2024-Shell-Challenge"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/9801daf5.html#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="shell挑战性任务">Shell挑战性任务</h1>
<h2 id="任务要求">任务要求</h2>
<p>本次挑战性任务是在 lab6 实现的 MOS Shell 基础上继续实现新的功能。</p>
<h3 id="实现功能">实现功能</h3>
<p>具体内容参考<a target="_blank" rel="noopener" href="https://github.com/EinNiemand28/EinNiemand28.github.io/blob/main/file/Shell%20%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1%20-%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC%E4%B9%A6.pdf">任务说明</a>。（各测试点间无依赖关系）</p>
<h3 id="关于shell">关于shell</h3>
<p>在 MOS 中，进程是一个很重要的概念，我们需要清楚 MOS 在运行的过程中存在哪些进程、这些进程之间的关系是什么，这有助于我们完成 shell 的相关任务。</p>
<p>比如，当我们启动 shell 时，它的 main 函数构成了一个新的进程。这个主进程主要负责完成命令的读取（<code>readline</code>）等工作（这个进程从 mosh 被打开到结束也都是不会被 free 的），不断有新的进程被 fork 出来通过调用<code>runcmd</code>去执行命令。在<code>runcmd</code>中，则首先调用<code>parsecmd</code>解析命令的参数。</p>
<p><code>parsecmd</code>通过返回<code>argc</code>表明完成对命令和参数的解析，或者递归调用<code>parsecmd</code>进行更复杂的解析工作。在这个过程中，主要通过<code>gettoken</code>和<code>_gettoken</code>对字符串命令进行拆解。</p>
<p>解析完成后，又会调用<code>spawn</code>函数加载对应的可执行文件、fork 新的进程并设置跳转入口，以执行对应的命令。<code>spawn</code>会返回这个进程的 id ，使父进程得以<strong>等待</strong>（或根据要实现的功能进程不同的处理）子进程完成可执行文件的运行（所有会结束的进程最后会调用<code>exit()</code>），然后父进程也就将结束它的使命。</p>
<p>以上是 mosh 运行的大致逻辑，对这些有了基本的了解后，让我们着手开始增强 mosh 的功能吧。</p>
<h2 id="具体实现">具体实现</h2>
<h3 id="不带-b后缀指令">不带<code>.b</code>后缀指令</h3>
<p>只需在<code>spawn</code>加载可执行文件时进行额外判断即可，若可执行文件不存在，则添加<code>.b</code>后缀再次尝试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> ((fd = open(prog, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(cmd, prog);</span><br><span class="line">    <span class="built_in">strcat</span>(cmd, <span class="string">&quot;.b\0&quot;</span>); <span class="comment">// lib/string.c 中实现</span></span><br><span class="line">    <span class="comment">//debugf(&quot;cmd: %s\n&quot;, cmd);</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(cmd, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令条件执行">指令条件执行</h3>
<p>显然，这首先需要我们修改 MOS 中对用户进程<code>exit</code>的实现，使其能够返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// After fs is ready (lab5), all our open files should be closed before dying.</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> !defined(LAB) || LAB &gt;= 5</span></span><br><span class="line">    close_all();</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    env = &amp;envs[ENVX(syscall_getenvid())];</span><br><span class="line">    <span class="keyword">if</span> (envs[ENVX(env-&gt;env_parent_id)].env_ipc_recving != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//debugf(&quot;%d should send: %d\n&quot;, env-&gt;env_id, r);</span></span><br><span class="line">        ipc_send(env-&gt;env_parent_id, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    syscall_env_destroy(<span class="number">0</span>);</span><br><span class="line">    user_panic(<span class="string">&quot;unreachable code&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我采用了 <code>ipc</code> 来实现返回值的传递，当父进程需要返回值时，让子进程调用<code>ipc_send</code></p>
<p>以条件<code>||</code>为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">-2</span>: <span class="comment">// Or</span></span><br><span class="line">    <span class="keyword">if</span> ((*rightpipe = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> argc; <span class="comment">// 子进程执行左指令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        u_int who;</span><br><span class="line">        r = ipc_recv(&amp;who, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//debugf(&quot;%d %d %d\n&quot;, *rightpipe, who, r);</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 若左为真，则跳过之后的指令，直到遇到注释&#x27;#&#x27;，或者遇到条件&#x27;&amp;&amp;&#x27;能让它停下来</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                c = gettoken(<span class="number">0</span>, &amp;t);</span><br><span class="line">            &#125; <span class="keyword">while</span> (c != <span class="number">-1</span> &amp;&amp; c != <span class="string">&#x27;#&#x27;</span> &amp;&amp; c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parsecmd(argv, rightpipe, background); <span class="comment">// 可以继续解析</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>另外由于可执行文件执行之后的返回值不能直接传给上述父进程，所以可以修改<code>wait</code>函数，让其将值先返回给子进程，子进程再将此值返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(u_int envid)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意我们这里再 wait 中使用了 ipc，之后在其他地方再想使用这个 wait 时需要注意 ipc 是否会产生影响</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    u_int who;</span><br><span class="line">    e = &amp;envs[ENVX(envid)];</span><br><span class="line">    <span class="comment">// debugf(&quot;%08x waiting %08x\n&quot;, syscall_getenvid(), envid);</span></span><br><span class="line">    <span class="keyword">while</span> (e-&gt;env_id == envid &amp;&amp; e-&gt;env_status != ENV_FREE) &#123;</span><br><span class="line">        r = ipc_recv(&amp;who, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        syscall_yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sh.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">runcmd</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> child = spawn(argv[<span class="number">0</span>], argv);</span><br><span class="line">    <span class="keyword">if</span> (child &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        r = wait(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">exit</span>(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更多指令">更多指令</h3>
<blockquote>
<p>需要实现<code>touch</code>、<code>mkdir</code>、<code>rm</code>，并需要考虑给出的情形</p>
</blockquote>
<p>首先我们需要实现 MOS 的创建文件的用户接口（文件系统的接口已给出），新增以下内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fsreq.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_create</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">    u_int f_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, u_int f_type)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// serv.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_create</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, u_int f_type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fsipc_create(path, f_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fsipc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> f_type)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(path);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len &gt; MAXPATHLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_create</span> *<span class="title">req</span> =</span> (<span class="keyword">struct</span> Fsreq_create *) fsipcbuf;</span><br><span class="line">    req-&gt;f_type = f_type;</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) req-&gt;req_path, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fsipc(FSREQ_CREATE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// serv.c</span></span><br><span class="line"><span class="type">void</span> *serve_table[MAX_FSREQNO] = &#123;</span><br><span class="line">    ..., [FSREQ_CREATE] = serve_create,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_create</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_create *rq)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = file_create(rq-&gt;req_path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f-&gt;f_type = rq-&gt;f_type;</span><br><span class="line">    ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，对于普通的<code>touch</code>和<code>mkdir</code>命令，我们只需要在对应<code>*.c</code>文件中进行以下操作即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> r = create(argv[<span class="number">1</span>], FTYPE_REG); <span class="comment">// 或修改类型为 FTYPE_DIR 以创建文件目录</span></span><br></pre></td></tr></table></figure>
<hr>
<p>对于<code>mkdir</code>，我们需要额外实现<code>-p</code>参数：当使用 <code>-p</code> 选项时忽略错误，若目录已存在则直接退出，若创建目录的父目录不存在则递归创建目录。</p>
<p>首先我们可以借助 ARG 宏来解析参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ARGBEGIN &#123;</span><br><span class="line">    <span class="comment">// 以此类推</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">        pmod = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125; ARGEND</span><br><span class="line"><span class="comment">// 要注意解析完成后从 argv[0] 开始就是命令的执行参数</span></span><br></pre></td></tr></table></figure>
<p>对于<code>-p</code>参数，我的处理办法为，对路径进行解析，忽视错误对路径中每一个子目录进行创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *path = argv[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (*path == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    path++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(path);</span><br><span class="line">*(path + len) = <span class="string">&#x27;/&#x27;</span>; <span class="comment">// 方便创建最后一个目录</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(path + i) == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        *(path + i) = <span class="number">0</span>;</span><br><span class="line">        create(path, FTYPE_DIR);</span><br><span class="line">        *(path + i) = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>对于<code>rm</code>指令，用户接口<code>remove</code>已给出，直接使用即可</p>
<p>不过我们需要处理不同的情况</p>
<blockquote>
<ul>
<li><code>rm &lt;file&gt;</code>：若文件存在则删除 <code>&lt;file&gt;</code>，否则输出错误信息。</li>
<li><code>rm &lt;dir&gt;</code>：输出错误信息。</li>
<li><code>rm -r &lt;dir&gt;|&lt;file&gt;</code>：若文件或文件夹存在则删除，否则输出错误信息。</li>
<li><code>rm -rf &lt;dir&gt;|&lt;file&gt;</code>：如果对应文件或文件夹存在则删除，否则直接退出。</li>
</ul>
</blockquote>
<p>因此我们需要先获取路径对应的文件描述符，然后针对不同情况进行不同的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(argv[<span class="number">0</span>], O_RDONLY); <span class="comment">// 只读</span></span><br><span class="line"><span class="keyword">if</span> (rmod &amp;&amp; <span class="built_in">fmod</span>) &#123;</span><br><span class="line">    remove(argv[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rm: cannot remove \&#x27;%s\&#x27;: No such file or directory\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> Filefd *filefd = (<span class="keyword">struct</span> Filefd *) INDEX2FD(fd);</span><br><span class="line">        <span class="comment">// 获取文件描述符</span></span><br><span class="line">        <span class="keyword">if</span> (!rmod &amp;&amp; filefd-&gt;f_file.f_type == FTYPE_DIR) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;rm: cannot remove \&#x27;%s\&#x27;: Is a directory\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            remove(argv[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反引号">反引号</h3>
<blockquote>
<p>本次任务只需考虑<code>echo</code>进行的输出且数据较弱，故忽略<code>echo</code>指令和反引号，直接执行反引号中的指令貌似也能过。不过这里还是对反引号原有的要求进行了实现。</p>
</blockquote>
<p>首先我们在<code>SYMBOLS</code>里面添加反引号以完成识别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOLS <span class="string">&quot;&lt;|&gt;&amp;;()`#&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>这里我采用了如下的方式区分前后的反引号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> backquote;</span><br><span class="line"><span class="type">int</span> _gettoken(<span class="type">char</span> *s, <span class="type">char</span> **p1, <span class="type">char</span> **p2) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(SYMBOLS, *s)) &#123;</span><br><span class="line">        <span class="type">int</span> t = *s;</span><br><span class="line">        *p1 = s;</span><br><span class="line">        *s++ = <span class="number">0</span>;</span><br><span class="line">        *p2 = s;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="string">&#x27;`&#x27;</span>) &#123;</span><br><span class="line">            backquote ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用管道将反引号中指令的所有输出传给父进程，对其解析以作为使用反引号的指令的参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;`&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (backquote) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = pipe(p)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;failed to allocate a pipe: %d\n&quot;</span>, r);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((*rightpipe = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// fork 子进程指令解析反引号中内容</span></span><br><span class="line">            <span class="comment">// 并将标准输入端与管道写端相连</span></span><br><span class="line">            dup(p[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">            close(p[<span class="number">1</span>]);</span><br><span class="line">            close(p[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> parsecmd(argv, rightpipe, background);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将标准输入端与管道读端相连，使用 read 读取信息</span></span><br><span class="line">            dup(p[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">            close(p[<span class="number">0</span>]);</span><br><span class="line">            close(p[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">char</span> *tmp = (<span class="type">char</span> *) bf;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, count = <span class="number">0</span>; i &lt; MAXLEN; i++) &#123;</span><br><span class="line">                count += read(<span class="number">0</span>, bf + i, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (count == i) <span class="keyword">break</span>;</span><br><span class="line">                syscall_yield();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">strchr</span>(<span class="string">&quot;\t\r\n&quot;</span>, *tmp)) &#123;</span><br><span class="line">                *tmp++ = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以换行符进行分割</span></span><br><span class="line">            <span class="keyword">while</span> (*tmp) &#123;</span><br><span class="line">                <span class="type">char</span> *s1 = tmp;</span><br><span class="line">                <span class="keyword">while</span> (!<span class="built_in">strchr</span>(<span class="string">&quot;\t\r\n&quot;</span>, *tmp) &amp;&amp; *tmp) &#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">                *tmp++ = <span class="number">0</span>;</span><br><span class="line">                argv[argc++] = s1;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">strchr</span>(<span class="string">&quot;\t\r\n&quot;</span>, *tmp) &amp;&amp; *tmp) &#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                c = gettoken(<span class="number">0</span>, &amp;t);</span><br><span class="line">                <span class="comment">// 这里父进程需要跳过直到右引号的所有内容</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (c != <span class="string">&#x27;`&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> argc;</span><br><span class="line">        <span class="comment">// 子进程完成了对反引号中内容的解析，返回执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>这里最开始我使用原始的<code>wait</code>但是没有成功，因此使用了类似于轮询的方式完成了对数据的读取</p>
<p>不过后来我需要在<code>wait.c</code>中添加新的功能，所以上面比较丑陋的轮询方式可以简化为下面的函数调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check2</span><span class="params">(u_int envid)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    e = &amp;envs[ENVX(envid)];</span><br><span class="line">    <span class="keyword">while</span> (e-&gt;env_id == envid &amp;&amp; e-&gt;env_status != ENV_FREE) &#123;</span><br><span class="line">        syscall_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注释功能">注释功能</h3>
<p>这个比较简单，完成对<code>#</code>的识别后进行如下处理即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> argc;</span><br></pre></td></tr></table></figure>
<h3 id="一行多指令">一行多指令</h3>
<p>常规的进程 fork</p>
<p>需要注意的点是可能之前会有重定向，将输出指向了其他地方，这里需要将其重新指回控制台</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> ((*rightpipe = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> argc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(*rightpipe);</span><br><span class="line">        <span class="keyword">if</span> (redirect) &#123;</span><br><span class="line">            close(<span class="number">0</span>);</span><br><span class="line">            close(<span class="number">1</span>);</span><br><span class="line">            dup(opencons(), <span class="number">1</span>);</span><br><span class="line">            dup(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            redirect = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parsecmd(argv, rightpipe, background);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h3 id="追加重定向">追加重定向</h3>
<p>首先我们需要实现文件操作的<code>O_APPEND</code>模式，即追加写功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_APPEND 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// serv.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_open</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_open *rq)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    o-&gt;o_mode = rq-&gt;req_omode;</span><br><span class="line">    ff-&gt;f_fd.fd_omode = o-&gt;o_mode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ff-&gt;f_fd.fd_omode &amp; O_APPEND) &#123;</span><br><span class="line">        ff-&gt;f_fd.fd_offset = f-&gt;f_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>parsecmd</code>中进行相应的修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:; <span class="comment">// 这个分号是因为 C 语言不允许在 case 后面直接定义变量</span></span><br><span class="line">    <span class="type">int</span> cc = gettoken(<span class="number">0</span>, &amp;t);</span><br><span class="line">    <span class="type">int</span> mode = O_WRONLY | O_CREAT; <span class="comment">// 没有则创建</span></span><br><span class="line">    <span class="keyword">if</span> (cc == <span class="string">&#x27;&gt;&#x27;</span>) &#123; <span class="comment">// 判断是否是追加重定向</span></span><br><span class="line">        mode |= O_APPEND;</span><br><span class="line">        <span class="keyword">if</span> ((cc = gettoken(<span class="number">0</span>, &amp;t)) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;syntax error: &gt; not followed by word\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cc == <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">        mode |= O_TRUNC; <span class="comment">// 普通重定向需先清空文件内容</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debugf(<span class="string">&quot;syntax error: &gt; not followed by word\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = open(t, mode)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;failed to open \&#x27;%s\&#x27;: %d\n&quot;</span>, t, r);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fd = r;</span><br><span class="line">    dup(fd, <span class="number">1</span>); <span class="comment">// 标准输出端与对应文件符相连</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h3 id="引号支持">引号支持</h3>
<p>由于不用考虑引号和反引号的嵌套处理，所以也就相对简单，只需在<code>_gettoken</code>时将引号内所用内容标记为一个<code>word</code>（<code>w</code>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _gettoken(<span class="type">char</span> *s, <span class="type">char</span> **p1, <span class="type">char</span> **p2) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (*s == <span class="string">&#x27;\&quot;&#x27;</span>) &#123; <span class="comment">// 这个判断需要在其他所有情况的前面</span></span><br><span class="line">        *p1 = ++s;</span><br><span class="line">        <span class="keyword">while</span> (*s != <span class="string">&#x27;\&quot;&#x27;</span> &amp;&amp; *s++);</span><br><span class="line">        *s++ = <span class="number">0</span>;</span><br><span class="line">        *p2 = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="历史指令">历史指令</h3>
<p><s>重量级</s></p>
<p>首先本着要做就要做好的原则，我先实现了对键入命令任意位置的修改的支持（使用<kbd>←</kbd>,<kbd>→</kbd>,<kbd>Backspace</kbd>,<kbd>Del</kbd>），这样不仅看起来更加顺眼，还可以实现对历史指令的修改</p>
<p>查阅资料可知，我们需要判断的 ascii 为</p>
<table>
<thead>
<tr>
<th>键</th>
<th>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>←</td>
<td>\033[D</td>
</tr>
<tr>
<td>→</td>
<td>\033[C</td>
</tr>
<tr>
<td>↑</td>
<td>\033[A</td>
</tr>
<tr>
<td>↓</td>
<td>\033[B</td>
</tr>
<tr>
<td>Backspace</td>
<td>\b or 0x7f</td>
</tr>
<tr>
<td>Del</td>
<td>~</td>
</tr>
</tbody>
</table>
<p>通过以下宏我们可以实现光标的移动，从而能够通过输出新的内容覆盖指定位置的原有内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MoveLeft(x) debugf(<span class="string">&quot;\033[%dD&quot;</span>, x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MoveRight(x) debugf(<span class="string">&quot;\033[%dC&quot;</span>, x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MoveUp(x) debugf(<span class="string">&quot;\033[%dA&quot;</span>, x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Movedown(x) debugf(<span class="string">&quot;\033[%dB&quot;</span>, x)</span></span><br></pre></td></tr></table></figure>
<p>然后修改<code>readline</code>的逻辑，维护当前指令的长度<code>len</code>和光标位置<code>i</code>（表示在第i个字符前），以及历史指令的读取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r, len = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = read(<span class="number">0</span>, &amp;tmp, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                debugf(<span class="string">&quot;read error: %d\n&quot;</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (删除字符) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (方向键) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp == <span class="string">&#x27;\r&#x27;</span> || tmp == <span class="string">&#x27;\n&#x27;</span>) &#123; <span class="comment">// 结束</span></span><br><span class="line">            buf[len] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 普通字符</span></span><br><span class="line">            <span class="keyword">if</span> (i == len) &#123;</span><br><span class="line">                buf[i++] = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = len; j &gt; i; j--) &#123;</span><br><span class="line">                    buf[j] = buf[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                buf[i] = tmp;</span><br><span class="line">                buf[len + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                MoveLeft(++i); <span class="comment">// 光标移动至开头</span></span><br><span class="line">                debugf(<span class="string">&quot;%s&quot;</span>, buf); <span class="comment">// 显示新的内容</span></span><br><span class="line">                MoveLeft(len - i + <span class="number">1</span>); <span class="comment">// 将光标移动至原来的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            len += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步，对于退格键<kbd>Backspace</kbd>和删除键<kbd>Del</kbd>的处理，主要思路是用空格覆盖想要删除的字符（以实现删除效果），对于光标位置的计算没什么好说的，细心即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&#x27;\b&#x27;</span> || tmp == <span class="number">0x7f</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == len) &#123;</span><br><span class="line">            buf[--i] = <span class="number">0</span>;</span><br><span class="line">            MoveLeft(<span class="number">1</span>);</span><br><span class="line">            debugf(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            MoveLeft(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &lt; len - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                buf[j] = buf[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            buf[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            MoveLeft(i--);</span><br><span class="line">            debugf(<span class="string">&quot;%s &quot;</span>, buf);</span><br><span class="line">            MoveLeft(len - i);</span><br><span class="line">        &#125;</span><br><span class="line">        len -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp == <span class="string">&#x27;~&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; len; ++j) &#123;</span><br><span class="line">            buf[j] = buf[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        buf[--len] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            MoveLeft(i);</span><br><span class="line">        &#125;</span><br><span class="line">        debugf(<span class="string">&quot;%s &quot;</span>, buf);</span><br><span class="line">        MoveLeft(len - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于方向键的处理，左移右移比较直接，只需要注意不要移出范围</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp == <span class="string">&#x27;\033&#x27;</span>) &#123;</span><br><span class="line">    read(<span class="number">0</span>, &amp;tmp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        read(<span class="number">0</span>, &amp;tmp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">switch</span> (tmp) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">                    i += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    MoveLeft(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    i -= <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    MoveRight(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上下键的处理，我们先不考虑历史指令如何保存和读取，而是关注如何实现上下键的逻辑功能<br>
这里我采用了一个全局变量<code>hislen</code>来记录历史指令的数量、一个局部变量<code>hisline</code>来记录当前是哪条指令（<code>[0,hislen - 1]</code>表示历史指令），<code>histmp</code>用来保存当前输入的指令（因为可能会上键选取历史指令、最后又下键回到当前指令）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteLine</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> len)</span> &#123; <span class="comment">// 光标位置和buf长度</span></span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line">        MoveLeft(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">        debugf(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">        MoveLeft(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hisline = hislen;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp == <span class="string">&#x27;\033&#x27;</span>) &#123;</span><br><span class="line">        read(<span class="number">0</span>, &amp;tmp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            read(<span class="number">0</span>, &amp;tmp, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">switch</span> (tmp) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                    Movedown(<span class="number">1</span>); <span class="comment">// 将光标移回来</span></span><br><span class="line">                    <span class="keyword">if</span> (hisline == hislen) &#123;</span><br><span class="line">                        <span class="comment">// 保存一下当前输入的指令</span></span><br><span class="line">                        <span class="built_in">strcpy</span>(histmp, buf);</span><br><span class="line">                        *(histmp + len) = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hisline &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        hisline--;</span><br><span class="line">                        readHistory(hisline, buf);</span><br><span class="line">                        <span class="comment">// 读取第 hisline 条历史指令</span></span><br><span class="line">                        deleteLine(i, len);</span><br><span class="line">                        <span class="comment">// 清除当前行的所有内容</span></span><br><span class="line">                        debugf(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">                        len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">                        i = len;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">                    <span class="comment">//MoveUp(1); 往下则不用移动</span></span><br><span class="line">                    <span class="keyword">if</span> (hisline &lt; hislen - <span class="number">1</span>) &#123;</span><br><span class="line">                        hisline++;</span><br><span class="line">                        readHistory(hisline, buf);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hisline + <span class="number">1</span> == hislen) &#123;</span><br><span class="line">                        hisline++;</span><br><span class="line">                        <span class="built_in">strcpy</span>(buf, histmp);</span><br><span class="line">                        <span class="comment">// 回到当前指令</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    deleteLine(i, len);</span><br><span class="line">                    debugf(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">                    len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">                    i = len;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>现在我们可以开始尝试实现历史指令的功能了<br>
首先是初始化创建<code>/.mosh_history</code>文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((r = open(<span class="string">&quot;/.mosh_history&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (create(<span class="string">&quot;/.mosh_history&quot;</span>, FTYPE_REG) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;create failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于如何从文件中读取历史指令，我采用了一个数组<code>hisoffset</code>来记录每条指令的偏移，这样我们就可以通过<code>seek</code>和<code>read</code>来读取指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hislen, hisoffset[HISTFILESIZE + <span class="number">5</span>];</span><br><span class="line"><span class="comment">// hisoffset[i] -&gt; 前 (i+1) 条指令的长度之和 + (i+1) 个换行符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readHistory</span><span class="params">(<span class="type">int</span> line, <span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r, fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;/.mosh_history&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (line &gt;= hislen) &#123;</span><br><span class="line">        *buf = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> offset = (line &gt; <span class="number">0</span> ? hisoffset[line - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> len = (line &gt; <span class="number">0</span> ? hisoffset[line] - hisoffset[line - <span class="number">1</span>] : hisoffset[line]);</span><br><span class="line">    <span class="keyword">if</span> ((r = seek(fd, offset)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;seek failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = read(fd, buf, len)) != len) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    buf[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取指令需要注意的是最大指令条数为<code>HISTFILESIZE=20</code>，当超过时需要将最早的指令删除。这里我采用的是将后19条指令读出，清空文件，再和新指令一起写入的简单粗暴的方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">saveHistory</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r, fd;</span><br><span class="line">    <span class="keyword">if</span> (hislen &lt; HISTFILESIZE) &#123; <span class="comment">// 未达上限</span></span><br><span class="line">        <span class="keyword">if</span> ((fd = open(<span class="string">&quot;/.mosh_history&quot;</span>, O_WRONLY | O_APPEND)) &lt; <span class="number">0</span>) &#123; <span class="comment">// 追加写</span></span><br><span class="line">            user_panic(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">        *(buf + len) = <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 加换行符</span></span><br><span class="line">        len += <span class="number">1</span>;</span><br><span class="line">        *(buf + len) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((r = write(fd, buf, len)) != len) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hisoffset[hislen++] = len + (hislen &gt; <span class="number">0</span> ? hisoffset[hislen - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 已满</span></span><br><span class="line">        <span class="keyword">if</span> ((fd = open(<span class="string">&quot;/.mosh_history&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = seek(fd, hisoffset[<span class="number">0</span>])) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;seek failed&quot;</span>); <span class="comment">// 从第 1 条指令开始读</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = hisoffset[HISTFILESIZE - <span class="number">1</span>] - hisoffset[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 读出除第 0 条指令外的所有指令</span></span><br><span class="line">        <span class="keyword">if</span> ((r = read(fd, buftmp, len)) != len) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fd = open(<span class="string">&quot;/.mosh_history&quot;</span>, O_TRUNC | O_WRONLY)) &lt; <span class="number">0</span>) &#123; <span class="comment">// 清空</span></span><br><span class="line">            user_panic(<span class="string">&quot;trunc failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = write(fd, buftmp, len)) != len) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;%s\n&quot;</span>, buftmp);</span><br><span class="line">            debugf(<span class="string">&quot;%d %d\n&quot;</span>, len, r);</span><br><span class="line">            user_panic(<span class="string">&quot;rewrite error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fd = open(<span class="string">&quot;/.mosh_history&quot;</span>, O_WRONLY | O_APPEND)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;rewrite not correctly&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">        *(buf + len) = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        len += <span class="number">1</span>;</span><br><span class="line">        *(buf + len) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((r = write(fd, buf, len)) != len) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ttmp = hisoffset[<span class="number">0</span>]; <span class="comment">// 重新计算所有偏移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; HISTFILESIZE; i++) &#123;</span><br><span class="line">            hisoffset[i] = hisoffset[i + <span class="number">1</span>] - ttmp;</span><br><span class="line">        &#125;</span><br><span class="line">        hisoffset[hislen - <span class="number">1</span>] = hisoffset[hislen - <span class="number">2</span>] + len;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>history</code>指令，直接将其变为<code>cat /.mosh_history</code>即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">runcmd</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;history&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;history.b&quot;</span>)) &#123;</span><br><span class="line">        argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">        argv[<span class="number">1</span>] = <span class="string">&quot;.mosh_history&quot;</span>;</span><br><span class="line">        argc = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前后台任务管理">前后台任务管理</h3>
<blockquote>
<ul>
<li>当命令的末尾添加上 &amp; 符号时，该命令应该在后台执行</li>
<li>实现 jobs 指令列出当前 shell 中所有后台任务的状态。需要为任务创建 ID（每次启动 mosh 时，任务从 1 开始编号，每个新增任务编号应加 1），并且通过 jobs 指令输出包括：任务 ID（job_id）、任务的运行状态（status：可能的取值为 Running，Done）、任务的进程 ID（env_id）与运行任务时输入的指令（cmd）。</li>
<li>实现 fg 将后台任务带回前台继续运行，用户通过 fg &lt;job_id&gt; 的方式将对应任务带回前台。</li>
<li>实现 kill 指令，用户通过 kill &lt;job_id&gt; 来实现结束后台任务。</li>
<li>以上指令均需要设计为内置指令（与<code>history</code>一样）</li>
</ul>
</blockquote>
<p>坑点很多，相比于历史指令，这部分更是在 bug 里找 bug</p>
<p>总之这里收回前文对进程之间关系的强调伏笔，需要注意的是一定要在<code>mosh</code>的<strong>主进程</strong>中读写 jobs 的相关信息（子进程被 free 信息就没了），然后对于 ipc 的使用也要多加考虑，以防产生错误行为</p>
<hr>
<p>首先我们在每次读取到指令后就根据是否有<code>&amp;</code>符号来判断是否为后台任务，然后将其状态和指令保存在一个结构体数组中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> cmd[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> jobscount;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Job</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> env_id;</span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">1024</span>];</span><br><span class="line">&#125; jobs[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">savetask</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(cmd, s);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (s[len - <span class="number">1</span>] != <span class="string">&#x27;&amp;&#x27;</span> &amp;&amp; len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[len - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(jobs[++jobscount].cmd, cmd);</span><br><span class="line">        jobs[jobscount].status = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        readline(buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">        <span class="type">int</span> rr = savetask(buf);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着需要使用 ipc 去拿到对应的进程 id<br>
先将<code>runcmd</code>改为有返回值，其中与 jobs 相关的操作返回非 0 值，否则返回 0，然后通过类似之前处理条件操作的方法将值传回 mosh 主进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(runcmd(buf));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ret = wait(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>parsecmd</code>中解析命令时需要检测是否有<code>&amp;</code>符号，如果有则将参数<code>*background</code>置为 1，并在<code>runcmd</code>中返回执行该命令的进程 id ，然后记录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">parsecmd</span><span class="params">(<span class="type">char</span> **argv, <span class="type">int</span> *rightpipe, <span class="type">int</span> *background)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">        *background = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">runcmd</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> child = spawn(argv[<span class="number">0</span>], argv);</span><br><span class="line">    close_all();</span><br><span class="line">    <span class="keyword">if</span> (child &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (background) &#123;</span><br><span class="line">            r = <span class="number">0</span>; <span class="comment">// 不等待，即意味着在后台挂起</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = wait(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debugf(<span class="string">&quot;spawn %s: %d\n&quot;</span>, argv[<span class="number">0</span>], child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (background) &#123;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rr) &#123;</span><br><span class="line">            jobs[jobscount].env_id = ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>fg</code>指令，为了避免使用 ipc 时出现的各种玄学错误，最后选择了轮询等待对应的子进程执行完毕，然后<code>return 0</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        ret = ret * <span class="number">10</span> + (*s++ - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">runcmd</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> jobid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (jobid &lt;= jobscount) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;fg: job (%d) do not exist\n&quot;</span>, jobid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (jobs[jobid].status == <span class="number">0</span>) &#123;</span><br><span class="line">            debugf(<span class="string">&quot;fg: (0x%08x) not running\n&quot;</span>, jobs[jobid].env_id);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check2(jobs[jobid].env_id); <span class="comment">// 等待这个进程执行完</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check2</span><span class="params">(u_int envid)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    e = &amp;envs[ENVX(envid)];</span><br><span class="line">    <span class="keyword">while</span> (e-&gt;env_id == envid &amp;&amp; e-&gt;env_status != ENV_FREE) &#123;</span><br><span class="line">        syscall_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>kill</code>命令，直接返回任务 id ，然后再主进程中将这个进程设置为<code>ENV_NOT_RUNNABLE</code>即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &lt;= jobscount) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jobs[ret].status) &#123;</span><br><span class="line">        syscall_set_env_status(jobs[ret].env_id, ENV_NOT_RUNNABLE);</span><br><span class="line">        jobs[ret].status = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debugf(<span class="string">&quot;fg: (0x%08x) not running\n&quot;</span>, jobs[ret].env_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>jobs</code>指令，使用返回值<code>-1</code>来表示，然后在主进程输出对应的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= jobscount; i++) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;[%d] %-10s 0x%08x %s\n&quot;</span>, i, jobs[i].status ? <span class="string">&quot;Running&quot;</span> : <span class="string">&quot;Done&quot;</span>, jobs[i].env_id, jobs[i].cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外值得注意的是，任务挂起以后会自己执行完毕，所以方便起见我们需要每次查询对应进程是否结束（状态是否为<code>ENV_FREE</code>），并更新对应状态信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= jobscount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].status) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(jobs[i].env_id)) &#123;</span><br><span class="line">            jobs[i].status = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(u_int envid)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    e = &amp;envs[ENVX(envid)];</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;env_status == ENV_FREE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>BUAA-OS-2024-Shell-Challenge</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://einniemand.top/9801daf5.html">https://einniemand.top/9801daf5.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>EinNiemand</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-06-28</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-08-20</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/shell/">shell</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/EinNiemand28/my-img@master/images/wallroom-3840x2400-bg-0f87d04.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/ac93ecd3.html" title="BUAA-OS-2024-Lab6"><img class="cover" src="https://cdn.jsdelivr.net/gh/EinNiemand28/my-img@master/images/wallroom-3840x2160-bg-2b185ed.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUAA-OS-2024-Lab6</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/429d8dff.html" title="BUAA-OS-2024-Lab4"><img class="cover" src="https://cdn.jsdelivr.net/gh/EinNiemand28/my-img@master/images/wallhaven-z8dg9y_1920x1080.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-09</div><div class="title">BUAA-OS-2024-Lab4</div></div></a></div><div><a href="/359abd69.html" title="BUAA-OS-2024-Lab5"><img class="cover" src="https://cdn.jsdelivr.net/gh/EinNiemand28/my-img@master/images/wallroom-3840x2400-bg-0d2a216.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-09</div><div class="title">BUAA-OS-2024-Lab5</div></div></a></div><div><a href="/ac93ecd3.html" title="BUAA-OS-2024-Lab6"><img class="cover" src="https://cdn.jsdelivr.net/gh/EinNiemand28/my-img@master/images/wallroom-3840x2160-bg-2b185ed.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-09</div><div class="title">BUAA-OS-2024-Lab6</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/EinNiemand28/my-img@master/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">EinNiemand</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/EinNiemand28"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#shell%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.</span> <span class="toc-text">Shell挑战性任务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%A6%81%E6%B1%82"><span class="toc-number">1.1.</span> <span class="toc-text">任务要求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.1.</span> <span class="toc-text">实现功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Eshell"><span class="toc-number">1.1.2.</span> <span class="toc-text">关于shell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6-b%E5%90%8E%E7%BC%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.1.</span> <span class="toc-text">不带.b后缀指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.2.</span> <span class="toc-text">指令条件执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.3.</span> <span class="toc-text">更多指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BC%95%E5%8F%B7"><span class="toc-number">1.2.4.</span> <span class="toc-text">反引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.5.</span> <span class="toc-text">注释功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%A1%8C%E5%A4%9A%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.6.</span> <span class="toc-text">一行多指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.2.7.</span> <span class="toc-text">追加重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%8F%B7%E6%94%AF%E6%8C%81"><span class="toc-number">1.2.8.</span> <span class="toc-text">引号支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.9.</span> <span class="toc-text">历史指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.10.</span> <span class="toc-text">前后台任务管理</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By EinNiemand</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-api-sand-ten.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(init)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-api-sand-ten.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script defer src="/js/cursor.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>